From 07a4ea1067ec44c5da5abdfcdf9295239b3b5b87 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Wed, 18 Feb 2015 13:05:20 +0100
Subject: [PATCH] connman: RFS-5431 -> Implement tethering mode 'lone-ap'.

* Extend tethering code in connman to support three modes altogether:
  - 'nat', which is the default tethering mode
  - 'lone-ap', which is the one we are going to use for setup
  - 'bridged-ap', which is the one we are going to use in default
    operation mode on Expand.
* Implement 'lone-ap' mode, starting a DHCP-server on the wifi
  interface, but leaving the ethernet and wifi interfaces unconnected.
  This mode is going to be used during setup mode to connect the
  smartphone with the device.
* Add frequency parameter to tether command, which allows to set the
  frequency to be used by the AP-mode during tethering.
---
 client/commands.c          |  83 +++++++++++++++++++++++++++------
 doc/technology-api.txt     |  28 +++++++++++
 include/technology.h       |   7 +++
 plugins/bluetooth.c        |   1 +
 plugins/bluetooth_legacy.c |   2 +
 plugins/ethernet.c         |   2 +
 plugins/gadget.c           |   2 +
 plugins/wifi.c             |   8 ++--
 src/connman.h              |   4 +-
 src/technology.c           | 114 ++++++++++++++++++++++++++++++++++++++++++++-
 src/tethering.c            |  78 ++++++++++++++++++-------------
 11 files changed, 276 insertions(+), 53 deletions(-)

diff --git a/client/commands.c b/client/commands.c
index 9208016..9fdc24a 100644
--- a/client/commands.c
+++ b/client/commands.c
@@ -490,16 +490,21 @@ static int tether_set(char *technology, int set_tethering)
 struct tether_properties {
 	int ssid_result;
 	int passphrase_result;
+	int frequency_result;
+	int mode_result;
 	int set_tethering;
 };
 
 static int tether_update(struct tether_properties *tether)
 {
-	if (tether->ssid_result == 0 && tether->passphrase_result == 0)
+	if (tether->ssid_result == 0 && tether->passphrase_result == 0 &&
+			tether->frequency_result == 0 && tether->mode_result == 0)
 		return tether_set("wifi", tether->set_tethering);
 
 	if (tether->ssid_result != -EINPROGRESS &&
-			tether->passphrase_result != -EINPROGRESS) {
+			tether->passphrase_result != -EINPROGRESS &&
+			tether->frequency_result != -EINPROGRESS &&
+			tether->mode_result != -EINPROGRESS) {
 		g_free(tether);
 		return 0;
 	}
@@ -539,7 +544,40 @@ static int tether_set_passphrase_return(DBusMessageIter *iter,
 	return tether_update(tether);
 }
 
-static int tether_set_ssid(char *ssid, char *passphrase, int set_tethering)
+static int tether_set_frequency_return(DBusMessageIter *iter,
+		const char *error, void *user_data)
+{
+	struct tether_properties *tether = user_data;
+
+	if (!error) {
+		fprintf(stdout, "Wifi frequency set\n");
+		tether->frequency_result = 0;
+	} else {
+		fprintf(stderr, "Error setting wifi frequency: %s\n", error);
+		tether->frequency_result = -EINVAL;
+	}
+
+	return tether_update(tether);
+}
+
+static int tether_set_mode_return(DBusMessageIter *iter,
+		const char *error, void *user_data)
+{
+	struct tether_properties *tether = user_data;
+
+	if (!error) {
+		fprintf(stdout, "wifi mode set\n");
+		tether->mode_result = 0;
+	} else {
+		fprintf(stderr, "Error setting wifi mode: %s\n", error);
+		tether->mode_result = -EINVAL;
+	}
+
+	return tether_update(tether);
+}
+
+static int tether_set_ssid(char *ssid, char *passphrase, char *frequency,
+		char *mode, int set_tethering)
 {
 	struct tether_properties *tether = g_new(struct tether_properties, 1);
 
@@ -557,8 +595,22 @@ static int tether_set_ssid(char *ssid, char *passphrase, int set_tethering)
 			tether_set_passphrase_return, tether,
 			"TetheringPassphrase", DBUS_TYPE_STRING, &passphrase);
 
+	tether->frequency_result =__connmanctl_dbus_set_property(connection,
+			"/net/connman/technology/wifi",
+			"net.connman.Technology",
+			tether_set_frequency_return, tether,
+			"TetheringFrequency", DBUS_TYPE_STRING, &frequency);
+
+	tether->mode_result =__connmanctl_dbus_set_property(connection,
+			"/net/connman/technology/wifi",
+			"net.connman.Technology",
+			tether_set_mode_return, tether,
+			"TetheringMode", DBUS_TYPE_STRING, &mode);
+
 	if (tether->ssid_result != -EINPROGRESS &&
-			tether->passphrase_result != -EINPROGRESS) {
+			tether->passphrase_result != -EINPROGRESS &&
+			tether->frequency_result != -EINPROGRESS &&
+			tether->mode_result != -EINPROGRESS) {
 		g_free(tether);
 		return -ENXIO;
 	}
@@ -568,30 +620,33 @@ static int tether_set_ssid(char *ssid, char *passphrase, int set_tethering)
 
 static int cmd_tether(char *args[], int num, struct connman_option *options)
 {
-	char *ssid, *passphrase;
+	char *ssid, *passphrase, *frequency, *mode;
 	int set_tethering;
 
 	if (num < 3)
 		return -EINVAL;
 
-	passphrase = args[num - 1];
-	ssid = args[num - 2];
-
 	set_tethering = parse_boolean(args[2]);
 
 	if (strcmp(args[1], "wifi") == 0) {
 
-		if (num > 5)
+		if (num > 7)
 			return -E2BIG;
 
-		if (num == 5 && set_tethering == -1)
+		ssid = num > 3 ? args[3] : "";
+		passphrase = num > 4 ? args[4] : "";
+		frequency = num > 5 ? args[5] : "";
+		mode = num > 6 ? args[6] : "nat";
+
+		if (num == 7 && set_tethering == -1)
 			return -EINVAL;
 
 		if (num == 4)
 			set_tethering = -1;
 
 		if (num > 3)
-			return tether_set_ssid(ssid, passphrase, set_tethering);
+			return tether_set_ssid(ssid, passphrase, frequency,
+					mode, set_tethering);
 	}
 
 	if (num > 3)
@@ -2383,9 +2438,9 @@ static const struct {
 	  "Disables given technology or offline mode",
 	  lookup_technology_offline },
 	{ "tether", "<technology> on|off\n"
-	            "            wifi [on|off] <ssid> <passphrase> ",
-	                                  NULL,            cmd_tether,
-	  "Enable, disable tethering, set SSID and passphrase for wifi",
+	  "            wifi [on|off] <ssid> <passphrase> <frequency> <nat|bridged-ap|lone-ap>\n",
+	  NULL,            cmd_tether,
+	  "Enable, disable tethering, set SSID, passphrase, frequency (e.g. 2412) and mode for wifi",
 	  lookup_tether },
 	{ "services",     "[<service>]",  service_options, cmd_services,
 	  "Display services", lookup_service_arg },
diff --git a/doc/technology-api.txt b/doc/technology-api.txt
index f97eac0..6c28d36 100644
--- a/doc/technology-api.txt
+++ b/doc/technology-api.txt
@@ -97,3 +97,31 @@ Properties	boolean Powered [readwrite]
 			This property is only valid for the WiFi technology,
 			and is then mapped to the WPA pre-shared key clients
 			will have to use in order to establish a connection.
+
+		string TetheringFrequency [readwrite]
+
+			The frequency to be used by the access point during
+			tethering.
+
+			This property is only valid for the WiFi technology,
+			and is then mapped to the WiFi frequency where the
+			access point will listen for clients.
+
+		boolean TetheringMode [readwrite]
+
+			This option allows to set the operation mode for
+			tethering. These modes are supported:
+			- 'nat' (default) implements full tethering mode, such
+			  that a DHCP-server is started for the WiFi interface
+			  and NAT is done between the WiFi network and the
+			  wired network. In this mode, WiFi stations have access
+			  to the internet through the access point.
+			- 'bridged-ap' simply bridges together the WiFi and the
+			  wired network, relying on a DHCP server running somewhere
+			  in the wired network.
+			- 'lone-ap' starts the WiFi network in access point mode,
+			  i.e. a DHCP-server is started for the WiFi interface,
+			  but there's no connection between the WiFi and the wired
+			  network. In this mode, WiFi stations can talk to the
+			  access point, but do not have access to the wired network
+			  (or the internet).
diff --git a/include/technology.h b/include/technology.h
index d7fcdde..1c2bb2b 100644
--- a/include/technology.h
+++ b/include/technology.h
@@ -34,6 +34,12 @@ extern "C" {
  * @short_description: Functions for handling technology details
  */
 
+enum tethering_mode {
+	TETHERING_MODE_NAT = 1,
+	TETHERING_MODE_BRIDGED_AP = 2,
+	TETHERING_MODE_LONE_AP = 3,
+};
+
 struct connman_technology;
 
 void connman_technology_tethering_notify(struct connman_technology *technology,
@@ -59,6 +65,7 @@ struct connman_technology_driver {
 								int index);
 	int (*set_tethering) (struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
+				const char *frequency, enum tethering_mode tether_mode,
 				const char *bridge, bool enabled);
 	int (*set_regdom) (struct connman_technology *technology,
 						const char *alpha2);
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index 45cc319..d9d4b18 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -873,6 +873,7 @@ static void bluetooth_tech_remove(struct connman_technology *technology)
 
 static int bluetooth_tech_set_tethering(struct connman_technology *technology,
 		const char *identifier, const char *passphrase,
+		const char *frequency, enum tethering_mode tether_mode,
 		const char *bridge, bool enabled)
 {
 	GHashTableIter hash_iter;
diff --git a/plugins/bluetooth_legacy.c b/plugins/bluetooth_legacy.c
index 2d7a9e0..0ab9b92 100644
--- a/plugins/bluetooth_legacy.c
+++ b/plugins/bluetooth_legacy.c
@@ -1234,6 +1234,8 @@ static void disable_nap(gpointer key, gpointer value, gpointer user_data)
 
 static int tech_set_tethering(struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
+				const char *frequency,
+				enum tethering_mode tether_mode,
 				const char *bridge, bool enabled)
 {
 	struct tethering_info info = {
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index b8e52ce..c335f0c 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -309,6 +309,8 @@ static void eth_tech_disable_tethering(struct connman_technology *technology,
 
 static int eth_tech_set_tethering(struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
+				const char *frequency,
+				enum tethering_mode tether_mode,
 				const char *bridge, bool enabled)
 {
 	if (!connman_technology_is_tethering_allowed(
diff --git a/plugins/gadget.c b/plugins/gadget.c
index 94f6648..1569724 100644
--- a/plugins/gadget.c
+++ b/plugins/gadget.c
@@ -291,6 +291,8 @@ static void gadget_tech_disable_tethering(struct connman_technology *technology,
 
 static int gadget_tech_set_tethering(struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
+				const char *frequency,
+				enum tethering_mode tether_mode,
 				const char *bridge, bool enabled)
 {
 	DBG("bridge %s enabled %d", bridge, enabled);
diff --git a/plugins/wifi.c b/plugins/wifi.c
index 1f90a31..7bae7ae 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -2877,7 +2877,7 @@ struct wifi_tethering_info {
 	GSupplicantSSID *ssid;
 };
 
-static GSupplicantSSID *ssid_ap_init(const char *ssid, const char *passphrase)
+static GSupplicantSSID *ssid_ap_init(const char *ssid, const char *passphrase, const char *frequency)
 {
 	GSupplicantSSID *ap;
 
@@ -2889,7 +2889,7 @@ static GSupplicantSSID *ssid_ap_init(const char *ssid, const char *passphrase)
 	ap->ssid = ssid;
 	ap->ssid_len = strlen(ssid);
 	ap->scan_ssid = 0;
-	ap->freq = 2412;
+	ap->freq = frequency ? atoi(frequency) : 2412;
 
 	if (!passphrase || strlen(passphrase) == 0) {
 		ap->security = G_SUPPLICANT_SECURITY_NONE;
@@ -2982,6 +2982,8 @@ static void sta_remove_callback(int result,
 
 static int tech_set_tethering(struct connman_technology *technology,
 				const char *identifier, const char *passphrase,
+				const char *frequency,
+				enum tethering_mode tether_mode,
 				const char *bridge, bool enabled)
 {
 	GList *list;
@@ -3035,7 +3037,7 @@ static int tech_set_tethering(struct connman_technology *technology,
 		info->wifi = wifi;
 		info->technology = technology;
 		info->wifi->bridge = bridge;
-		info->ssid = ssid_ap_init(identifier, passphrase);
+		info->ssid = ssid_ap_init(identifier, passphrase, frequency);
 		if (!info->ssid) {
 			g_free(info);
 			continue;
diff --git a/src/connman.h b/src/connman.h
index 8d4a692..1f855e3 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -620,8 +620,8 @@ int __connman_tethering_init(void);
 void __connman_tethering_cleanup(void);
 
 const char *__connman_tethering_get_bridge(void);
-void __connman_tethering_set_enabled(void);
-void __connman_tethering_set_disabled(void);
+void __connman_tethering_set_enabled(enum tethering_mode tether_mode);
+void __connman_tethering_set_disabled(enum tethering_mode tether_mode);
 
 int __connman_private_network_request(DBusMessage *msg, const char *owner);
 int __connman_private_network_release(const char *path);
diff --git a/src/technology.c b/src/technology.c
index 8b26af0..175c778 100644
--- a/src/technology.c
+++ b/src/technology.c
@@ -66,6 +66,8 @@ struct connman_technology {
 					      */
 	char *tethering_ident;
 	char *tethering_passphrase;
+	char *tethering_frequency;
+	enum tethering_mode tethering_mode;
 
 	bool enable_persistent; /* Save the tech state */
 
@@ -155,11 +157,38 @@ static const char *get_name(enum connman_service_type type)
 	return NULL;
 }
 
+static enum tethering_mode tether_mode_from_string(const char *mode)
+{
+	if (g_strcmp0(mode, "nat") == 0)
+		return TETHERING_MODE_NAT;
+	if (g_strcmp0(mode, "bridged-ap") == 0)
+		return TETHERING_MODE_BRIDGED_AP;
+	if (g_strcmp0(mode, "lone-ap") == 0)
+		return TETHERING_MODE_LONE_AP;
+
+	return -1;
+}
+
+static char * tether_mode_to_string(enum tethering_mode mode)
+{
+	switch (mode) {
+	case TETHERING_MODE_NAT:
+		return "nat";
+	case TETHERING_MODE_BRIDGED_AP:
+		return "bridged-ap";
+	case TETHERING_MODE_LONE_AP:
+		return "lone-ap";
+	}
+
+	return NULL;
+}
+
 static void technology_save(struct connman_technology *technology)
 {
 	GKeyFile *keyfile;
 	gchar *identifier;
 	const char *name = get_name(technology->type);
+	char* tether_mode;
 
 	DBG("technology %p type %d name %s", technology, technology->type,
 									name);
@@ -190,6 +219,16 @@ static void technology_save(struct connman_technology *technology)
 					"Tethering.Passphrase",
 					technology->tethering_passphrase);
 
+	if (technology->tethering_frequency)
+		g_key_file_set_string(keyfile, identifier,
+					"Tethering.Frequency",
+					technology->tethering_frequency);
+
+	tether_mode = tether_mode_to_string(technology->tethering_mode);
+	if (tether_mode)
+		g_key_file_set_string(keyfile, identifier,
+					"Tethering.Mode", tether_mode);
+
 done:
 	g_free(identifier);
 
@@ -224,9 +263,9 @@ void connman_technology_tethering_notify(struct connman_technology *technology,
 	tethering_changed(technology);
 
 	if (enabled)
-		__connman_tethering_set_enabled();
+		__connman_tethering_set_enabled(technology->tethering_mode);
 	else
-		__connman_tethering_set_disabled();
+		__connman_tethering_set_disabled(technology->tethering_mode);
 }
 
 static int set_tethering(struct connman_technology *technology,
@@ -259,7 +298,12 @@ static int set_tethering(struct connman_technology *technology,
 		if (!driver || !driver->set_tethering)
 			continue;
 
+		if (enabled && !technology->tethering_mode)
+			technology->tethering_mode = TETHERING_MODE_NAT;
+
 		err = driver->set_tethering(technology, ident, passphrase,
+				technology->tethering_frequency,
+				technology->tethering_mode,
 				bridge, enabled);
 
 		if (result == -EINPROGRESS)
@@ -379,6 +423,7 @@ static void technology_load(struct connman_technology *technology)
 	GKeyFile *keyfile;
 	gchar *identifier;
 	GError *error = NULL;
+	enum tethering_mode tether_mode;
 	bool enable, need_saving = false;
 
 	DBG("technology %p", technology);
@@ -428,6 +473,16 @@ static void technology_load(struct connman_technology *technology)
 
 	technology->tethering_passphrase = g_key_file_get_string(keyfile,
 				identifier, "Tethering.Passphrase", NULL);
+
+	technology->tethering_frequency = g_key_file_get_string(keyfile,
+				identifier, "Tethering.Frequency", NULL);
+
+	tether_mode = tether_mode_from_string(g_key_file_get_string(keyfile,
+				identifier, "Tethering.Mode", NULL));
+	technology->tethering_mode = tether_mode < 0
+			? TETHERING_MODE_NAT
+			: tether_mode;
+
 done:
 	g_free(identifier);
 
@@ -527,6 +582,16 @@ static void append_properties(DBusMessageIter *iter,
 					DBUS_TYPE_STRING,
 					&technology->tethering_passphrase);
 
+	if (technology->tethering_frequency)
+		connman_dbus_dict_append_basic(&dict, "TetheringFrequency",
+					DBUS_TYPE_STRING,
+					&technology->tethering_frequency);
+
+	str = tether_mode_to_string(technology->tethering_mode);
+	if (str)
+		connman_dbus_dict_append_basic(&dict, "TetheringMode",
+					DBUS_TYPE_STRING, &str);
+
 	connman_dbus_dict_close(iter, &dict);
 }
 
@@ -934,6 +999,50 @@ static DBusMessage *set_property(DBusConnection *conn,
 					DBUS_TYPE_STRING,
 					&technology->tethering_passphrase);
 		}
+	} else if (g_str_equal(name, "TetheringFrequency")) {
+		const char *str;
+
+		dbus_message_iter_get_basic(&value, &str);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_WIFI)
+			return __connman_error_not_supported(msg);
+
+		if (strlen(str) < 1 || strlen(str) > 32)
+			return __connman_error_invalid_arguments(msg);
+
+		if (g_strcmp0(technology->tethering_frequency, str) != 0) {
+			g_free(technology->tethering_frequency);
+			technology->tethering_frequency = g_strdup(str);
+			technology_save(technology);
+
+			connman_dbus_property_changed_basic(technology->path,
+						CONNMAN_TECHNOLOGY_INTERFACE,
+						"TetheringFrequency",
+						DBUS_TYPE_STRING,
+						&technology->tethering_frequency);
+		}
+	} else if (g_str_equal(name, "TetheringMode")) {
+		const char *str;
+
+		dbus_message_iter_get_basic(&value, &str);
+
+		if (technology->type != CONNMAN_SERVICE_TYPE_WIFI)
+			return __connman_error_not_supported(msg);
+
+		enum tethering_mode tether_mode = tether_mode_from_string(str);
+		if (tether_mode < 0)
+			return __connman_error_invalid_arguments(msg);
+
+		if (technology->tethering_mode != tether_mode) {
+			technology->tethering_mode = tether_mode;
+			technology_save(technology);
+
+			connman_dbus_property_changed_basic(technology->path,
+						CONNMAN_TECHNOLOGY_INTERFACE,
+						"TetheringMode",
+						DBUS_TYPE_STRING,
+						&str);
+		}
 	} else if (g_str_equal(name, "Powered")) {
 		dbus_bool_t enable;
 
@@ -1146,6 +1255,7 @@ static void technology_put(struct connman_technology *technology)
 	g_free(technology->regdom);
 	g_free(technology->tethering_ident);
 	g_free(technology->tethering_passphrase);
+	g_free(technology->tethering_frequency);
 	g_free(technology);
 }
 
diff --git a/src/tethering.c b/src/tethering.c
index ceeec74..c465e79 100644
--- a/src/tethering.c
+++ b/src/tethering.c
@@ -176,12 +176,13 @@ static void dhcp_server_stop(GDHCPServer *server)
 
 static void tethering_restart(struct connman_ippool *pool, void *user_data)
 {
+	enum tethering_mode tether_mode = *(enum tethering_mode*)(user_data);
 	DBG("pool %p", pool);
-	__connman_tethering_set_disabled();
-	__connman_tethering_set_enabled();
+	__connman_tethering_set_disabled(tether_mode);
+	__connman_tethering_set_enabled(tether_mode);
 }
 
-void __connman_tethering_set_enabled(void)
+void __connman_tethering_set_enabled(enum tethering_mode tether_mode)
 {
 	int index;
 	int err;
@@ -206,20 +207,27 @@ void __connman_tethering_set_enabled(void)
 	}
 
 	index = connman_inet_ifindex(BRIDGE_NAME);
-	dhcp_ippool = __connman_ippool_create(index, 2, 252,
-						tethering_restart, NULL);
-	if (!dhcp_ippool) {
-		connman_error("Fail to create IP pool");
-		__connman_bridge_remove(BRIDGE_NAME);
-		__sync_fetch_and_sub(&tethering_enabled, 1);
+
+	if (tether_mode == TETHERING_MODE_BRIDGED_AP) {
+		// TODO: implement!
+		connman_error("bridged-ap mode is not implemented yet!\n");
 		return;
-	}
+	} else {
+		dhcp_ippool = __connman_ippool_create(index, 2, 252,
+					tethering_restart, &tether_mode);
+		if (!dhcp_ippool) {
+			connman_error("Fail to create IP pool");
+			__connman_bridge_remove(BRIDGE_NAME);
+			__sync_fetch_and_sub(&tethering_enabled, 1);
+			return;
+		}
 
-	gateway = __connman_ippool_get_gateway(dhcp_ippool);
-	broadcast = __connman_ippool_get_broadcast(dhcp_ippool);
-	subnet_mask = __connman_ippool_get_subnet_mask(dhcp_ippool);
-	start_ip = __connman_ippool_get_start_ip(dhcp_ippool);
-	end_ip = __connman_ippool_get_end_ip(dhcp_ippool);
+		gateway = __connman_ippool_get_gateway(dhcp_ippool);
+		broadcast = __connman_ippool_get_broadcast(dhcp_ippool);
+		subnet_mask = __connman_ippool_get_subnet_mask(dhcp_ippool);
+		start_ip = __connman_ippool_get_start_ip(dhcp_ippool);
+		end_ip = __connman_ippool_get_end_ip(dhcp_ippool);
+	}
 
 	err = __connman_bridge_enable(BRIDGE_NAME, gateway,
 			connman_ipaddress_calc_netmask_len(subnet_mask),
@@ -267,27 +275,30 @@ void __connman_tethering_set_enabled(void)
 		return;
 	}
 
-	prefixlen = connman_ipaddress_calc_netmask_len(subnet_mask);
-	err = __connman_nat_enable(BRIDGE_NAME, start_ip, prefixlen);
-	if (err < 0) {
-		connman_error("Cannot enable NAT %d/%s", err, strerror(-err));
-		dhcp_server_stop(tethering_dhcp_server);
-		__connman_bridge_disable(BRIDGE_NAME);
-		__connman_ippool_unref(dhcp_ippool);
-		__connman_bridge_remove(BRIDGE_NAME);
-		__sync_fetch_and_sub(&tethering_enabled, 1);
-		return;
+	if (tether_mode == TETHERING_MODE_NAT) {
+		prefixlen = connman_ipaddress_calc_netmask_len(subnet_mask);
+		err = __connman_nat_enable(BRIDGE_NAME, start_ip, prefixlen);
+		if (err < 0) {
+			connman_error("Cannot enable NAT %d/%s", err, strerror(-err));
+			dhcp_server_stop(tethering_dhcp_server);
+			__connman_bridge_disable(BRIDGE_NAME);
+			__connman_ippool_unref(dhcp_ippool);
+			__connman_bridge_remove(BRIDGE_NAME);
+			__sync_fetch_and_sub(&tethering_enabled, 1);
+			return;
+		}
 	}
 
 	err = __connman_ipv6pd_setup(BRIDGE_NAME);
-	if (err < 0 && err != -EINPROGRESS)
+	if (err < 0 && err != -EINPROGRESS) {
 		DBG("Cannot setup IPv6 prefix delegation %d/%s", err,
 			strerror(-err));
+	}
 
 	DBG("tethering started");
 }
 
-void __connman_tethering_set_disabled(void)
+void __connman_tethering_set_disabled(enum tethering_mode tether_mode)
 {
 	int index;
 
@@ -301,15 +312,18 @@ void __connman_tethering_set_disabled(void)
 	index = connman_inet_ifindex(BRIDGE_NAME);
 	__connman_dnsproxy_remove_listener(index);
 
-	__connman_nat_disable(BRIDGE_NAME);
-
-	dhcp_server_stop(tethering_dhcp_server);
+	if (tether_mode == TETHERING_MODE_NAT)
+		__connman_nat_disable(BRIDGE_NAME);
 
-	tethering_dhcp_server = NULL;
+	if (tethering_dhcp_server) {
+		dhcp_server_stop(tethering_dhcp_server);
+		tethering_dhcp_server = NULL;
+	}
 
 	__connman_bridge_disable(BRIDGE_NAME);
 
-	__connman_ippool_unref(dhcp_ippool);
+	if (tether_mode != TETHERING_MODE_BRIDGED_AP)
+		__connman_ippool_unref(dhcp_ippool);
 
 	__connman_bridge_remove(BRIDGE_NAME);
 
-- 
1.8.4.5

