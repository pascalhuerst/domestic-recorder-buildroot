From def172a44818aa83e646b42536d6c1d5dfec1749 Mon Sep 17 00:00:00 2001
From: Oliver Tappe <zooey@hirschkaefer.de>
Date: Thu, 12 Mar 2015 15:30:07 +0100
Subject: [PATCH 3/3] connman: RFS-5503 -> Fix lone-ap mode for mwifiex
 devices.

* For some unknown reason, the tether bridge device does not see the
  dhcp requests done by the first connecting client.
  Lone-AP mode does not need the bridge device per se, so in order to
  circumvent the problem, we no longer use the bridge device in lone-ap
  mode, but use the wireless device directly.
  The code is far from nice (as we have to bridge different layers of
  concern in connman's code), but it seems to work such that even the
  first client can connect to the soft-AP of mwifiex devices reliably.
---
 include/technology.h       |  2 +-
 plugins/bluetooth.c        |  2 +-
 plugins/bluetooth_legacy.c |  4 ++--
 plugins/ethernet.c         |  4 ++--
 plugins/gadget.c           |  4 ++--
 plugins/wifi.c             |  8 ++++----
 src/connman.h              |  2 +-
 src/technology.c           |  4 ++--
 src/tethering.c            | 38 ++++++++++++++++++++++++++++----------
 9 files changed, 43 insertions(+), 25 deletions(-)

diff --git a/include/technology.h b/include/technology.h
index 1c2bb2b..90ccb81 100644
--- a/include/technology.h
+++ b/include/technology.h
@@ -43,7 +43,7 @@ enum tethering_mode {
 struct connman_technology;
 
 void connman_technology_tethering_notify(struct connman_technology *technology,
-							bool enabled);
+							bool enabled, const char *ifname);
 int connman_technology_set_regdom(const char *alpha2);
 void connman_technology_regdom_notify(struct connman_technology *technology,
 							const char *alpha2);
diff --git a/plugins/bluetooth.c b/plugins/bluetooth.c
index d9d4b18..5d53547 100644
--- a/plugins/bluetooth.c
+++ b/plugins/bluetooth.c
@@ -688,7 +688,7 @@ static void tethering_create_cb(DBusMessage *message, void *user_data)
 
 	if (tethering->technology)
 		connman_technology_tethering_notify(tethering->technology,
-				tethering->enable);
+				tethering->enable, NULL);
 }
 
 static void tethering_append(DBusMessageIter *iter, void *user_data)
diff --git a/plugins/bluetooth_legacy.c b/plugins/bluetooth_legacy.c
index 0ab9b92..5a9efb6 100644
--- a/plugins/bluetooth_legacy.c
+++ b/plugins/bluetooth_legacy.c
@@ -1122,7 +1122,7 @@ static void server_register_reply(DBusPendingCall *call, void *user_data)
 	dbus_message_unref(reply);
 	dbus_pending_call_unref(call);
 
-	connman_technology_tethering_notify(technology, true);
+	connman_technology_tethering_notify(technology, true, NULL);
 }
 
 static void server_unregister_reply(DBusPendingCall *call, void *user_data)
@@ -1148,7 +1148,7 @@ static void server_unregister_reply(DBusPendingCall *call, void *user_data)
 	dbus_message_unref(reply);
 	dbus_pending_call_unref(call);
 
-	connman_technology_tethering_notify(technology, false);
+	connman_technology_tethering_notify(technology, false, NULL);
 }
 
 
diff --git a/plugins/ethernet.c b/plugins/ethernet.c
index c335f0c..460e5b0 100644
--- a/plugins/ethernet.c
+++ b/plugins/ethernet.c
@@ -276,7 +276,7 @@ static void eth_tech_enable_tethering(struct connman_technology *technology,
 				remove_network(device, ethernet);
 		}
 
-		connman_technology_tethering_notify(technology, true);
+		connman_technology_tethering_notify(technology, true, NULL);
 
 		connman_inet_ifup(index);
 
@@ -298,7 +298,7 @@ static void eth_tech_disable_tethering(struct connman_technology *technology,
 
 		connman_inet_remove_from_bridge(index, bridge);
 
-		connman_technology_tethering_notify(technology, false);
+		connman_technology_tethering_notify(technology, false, NULL);
 
 		if (device)
 			connman_device_reconnect_service(device);
diff --git a/plugins/gadget.c b/plugins/gadget.c
index 1569724..3ae74ec 100644
--- a/plugins/gadget.c
+++ b/plugins/gadget.c
@@ -265,7 +265,7 @@ static void gadget_tech_enable_tethering(struct connman_technology *technology,
 				remove_network(device, gadget);
 		}
 
-		connman_technology_tethering_notify(technology, true);
+		connman_technology_tethering_notify(technology, true, NULL);
 
 		connman_inet_ifup(index);
 
@@ -285,7 +285,7 @@ static void gadget_tech_disable_tethering(struct connman_technology *technology,
 
 		connman_inet_ifdown(index);
 
-		connman_technology_tethering_notify(technology, false);
+		connman_technology_tethering_notify(technology, false, NULL);
 	}
 }
 
diff --git a/plugins/wifi.c b/plugins/wifi.c
index c2925de..24bae74 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -2920,7 +2920,7 @@ static void ap_start_callback(int result, GSupplicantInterface *interface,
 	if (result < 0) {
 		connman_inet_remove_from_bridge(info->wifi->index,
 							info->wifi->bridge);
-		connman_technology_tethering_notify(info->technology, false);
+		connman_technology_tethering_notify(info->technology, false, NULL);
 	}
 
 	g_free(info->ifname);
@@ -2939,7 +2939,7 @@ static void ap_create_callback(int result,
 	if (result < 0) {
 		connman_inet_remove_from_bridge(info->wifi->index,
 							info->wifi->bridge);
-		connman_technology_tethering_notify(info->technology, false);
+		connman_technology_tethering_notify(info->technology, false, NULL);
 
 		g_free(info->ifname);
 		g_free(info->ssid);
@@ -2977,7 +2977,7 @@ static void sta_remove_callback(int result,
 
 	info->wifi->interface = NULL;
 
-	connman_technology_tethering_notify(info->technology, true);
+	connman_technology_tethering_notify(info->technology, true, info->ifname);
 
 	g_supplicant_interface_create(info->ifname, driver, info->wifi->bridge,
 						ap_create_callback,
@@ -3013,7 +3013,7 @@ static int tech_set_tethering(struct connman_technology *technology,
 			}
 		}
 
-		connman_technology_tethering_notify(technology, false);
+		connman_technology_tethering_notify(technology, false, NULL);
 
 		return 0;
 	}
diff --git a/src/connman.h b/src/connman.h
index 1f855e3..ca35d81 100644
--- a/src/connman.h
+++ b/src/connman.h
@@ -620,7 +620,7 @@ int __connman_tethering_init(void);
 void __connman_tethering_cleanup(void);
 
 const char *__connman_tethering_get_bridge(void);
-void __connman_tethering_set_enabled(enum tethering_mode tether_mode);
+void __connman_tethering_set_enabled(enum tethering_mode tether_mode, const char *ifname);
 void __connman_tethering_set_disabled(enum tethering_mode tether_mode);
 
 int __connman_private_network_request(DBusMessage *msg, const char *owner);
diff --git a/src/technology.c b/src/technology.c
index 8c8b349..da3ae7e 100644
--- a/src/technology.c
+++ b/src/technology.c
@@ -251,7 +251,7 @@ static void tethering_changed(struct connman_technology *technology)
 }
 
 void connman_technology_tethering_notify(struct connman_technology *technology,
-							bool enabled)
+							bool enabled, const char *ifname)
 {
 	DBG("technology %p enabled %u", technology, enabled);
 
@@ -263,7 +263,7 @@ void connman_technology_tethering_notify(struct connman_technology *technology,
 	tethering_changed(technology);
 
 	if (enabled)
-		__connman_tethering_set_enabled(technology->tethering_mode);
+		__connman_tethering_set_enabled(technology->tethering_mode, ifname);
 	else
 		__connman_tethering_set_disabled(technology->tethering_mode);
 }
diff --git a/src/tethering.c b/src/tethering.c
index c465e79..b8c984b 100644
--- a/src/tethering.c
+++ b/src/tethering.c
@@ -174,15 +174,21 @@ static void dhcp_server_stop(GDHCPServer *server)
 	g_dhcp_server_unref(server);
 }
 
+struct restart_data
+{
+	enum tethering_mode tether_mode;
+	const char *ifname;
+} g_restart_data;
+
 static void tethering_restart(struct connman_ippool *pool, void *user_data)
 {
-	enum tethering_mode tether_mode = *(enum tethering_mode*)(user_data);
+	struct restart_data *data = (struct restart_data *)(user_data);
 	DBG("pool %p", pool);
-	__connman_tethering_set_disabled(tether_mode);
-	__connman_tethering_set_enabled(tether_mode);
+	__connman_tethering_set_disabled(data->tether_mode);
+	__connman_tethering_set_enabled(data->tether_mode, data->ifname);
 }
 
-void __connman_tethering_set_enabled(enum tethering_mode tether_mode)
+void __connman_tethering_set_enabled(enum tethering_mode tether_mode, const char *ifname)
 {
 	int index;
 	int err;
@@ -192,6 +198,7 @@ void __connman_tethering_set_enabled(enum tethering_mode tether_mode)
 	const char *start_ip;
 	const char *end_ip;
 	const char *dns;
+	const char *dhcp_interface;
 	unsigned char prefixlen;
 	char **ns;
 
@@ -206,15 +213,22 @@ void __connman_tethering_set_enabled(enum tethering_mode tether_mode)
 		return;
 	}
 
-	index = connman_inet_ifindex(BRIDGE_NAME);
+	if (tether_mode == TETHERING_MODE_LONE_AP && ifname)
+		dhcp_interface = ifname;
+	else
+		dhcp_interface = BRIDGE_NAME;
+
+	index = connman_inet_ifindex(dhcp_interface);
 
 	if (tether_mode == TETHERING_MODE_BRIDGED_AP) {
 		// TODO: implement!
 		connman_error("bridged-ap mode is not implemented yet!\n");
 		return;
 	} else {
+		g_restart_data.tether_mode = tether_mode;
+		g_restart_data.ifname = ifname;
 		dhcp_ippool = __connman_ippool_create(index, 2, 252,
-					tethering_restart, &tether_mode);
+					tethering_restart, &g_restart_data);
 		if (!dhcp_ippool) {
 			connman_error("Fail to create IP pool");
 			__connman_bridge_remove(BRIDGE_NAME);
@@ -229,7 +243,7 @@ void __connman_tethering_set_enabled(enum tethering_mode tether_mode)
 		end_ip = __connman_ippool_get_end_ip(dhcp_ippool);
 	}
 
-	err = __connman_bridge_enable(BRIDGE_NAME, gateway,
+	err = __connman_bridge_enable(dhcp_interface, gateway,
 			connman_ipaddress_calc_netmask_len(subnet_mask),
 			broadcast);
 	if (err < 0 && err != -EALREADY) {
@@ -263,12 +277,12 @@ void __connman_tethering_set_enabled(enum tethering_mode tether_mode)
 		DBG("Serving %s nameserver to clients", dns);
 	}
 
-	tethering_dhcp_server = dhcp_server_start(BRIDGE_NAME,
+	tethering_dhcp_server = dhcp_server_start(dhcp_interface,
 						gateway, subnet_mask,
 						start_ip, end_ip,
 						24 * 3600, dns);
 	if (!tethering_dhcp_server) {
-		__connman_bridge_disable(BRIDGE_NAME);
+		__connman_bridge_disable(dhcp_interface);
 		__connman_ippool_unref(dhcp_ippool);
 		__connman_bridge_remove(BRIDGE_NAME);
 		__sync_fetch_and_sub(&tethering_enabled, 1);
@@ -309,7 +323,11 @@ void __connman_tethering_set_disabled(enum tethering_mode tether_mode)
 
 	__connman_ipv6pd_cleanup();
 
-	index = connman_inet_ifindex(BRIDGE_NAME);
+	if (tether_mode == TETHERING_MODE_LONE_AP)
+		index = connman_inet_ifindex("uap0");
+	else
+		index = connman_inet_ifindex(BRIDGE_NAME);
+
 	__connman_dnsproxy_remove_listener(index);
 
 	if (tether_mode == TETHERING_MODE_NAT)
-- 
1.8.4.5

