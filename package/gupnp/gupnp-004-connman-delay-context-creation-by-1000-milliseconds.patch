From 95b87f45e66ebe4a7f52fa5aeb06d0ce9dcf659a Mon Sep 17 00:00:00 2001
From: Sven Neumann <neumann@teufel.de>
Date: Wed, 1 Jul 2015 14:23:24 +0200
Subject: [PATCH] connman: delay context creation by 1000 milliseconds

It appears that connman signals an interface to be 'ready' as
soon as it has an IP. However the routes may not have been
configured correctly at this point. This should actually be
fixed in connman, but for now it seems easier to work around
the problem here.
---
 libgupnp/gupnp-connman-manager.c | 48 +++++++++++++++++++++++++++++++++++-----
 1 file changed, 42 insertions(+), 6 deletions(-)

diff --git a/libgupnp/gupnp-connman-manager.c b/libgupnp/gupnp-connman-manager.c
index afce14c..dd70d02 100644
--- a/libgupnp/gupnp-connman-manager.c
+++ b/libgupnp/gupnp-connman-manager.c
@@ -33,6 +33,8 @@
 #include "gupnp-context.h"
 #include "gupnp-marshal.h"
 
+#define SERVICE_CREATION_TIMEOUT 1000
+
 typedef enum
 {
         CM_SERVICE_STATE_ACTIVE   = 1,
@@ -49,7 +51,7 @@ typedef struct {
         guint               port;
         gchar               *iface;
         gchar               *name;
-
+        guint               timeout;
 } CMService;
 
 struct _GUPnPConnmanManagerPrivate {
@@ -147,16 +149,48 @@ service_context_delete (CMService *cm_service)
         cm_service->context = NULL;
 }
 
+static gboolean
+service_context_create_timeout (CMService *cm_service)
+{
+        cm_service->timeout = 0;
+
+        g_return_val_if_fail (cm_service->current == CM_SERVICE_STATE_ACTIVE, FALSE);
+
+        if (service_context_create (cm_service) == FALSE) {
+                cm_service->current = CM_SERVICE_STATE_INACTIVE;
+        }
+
+        return FALSE;
+}
+
+static void
+service_context_remove_creation_timeout (CMService *cm_service)
+{
+        if (cm_service->timeout) {
+                g_source_remove (cm_service->timeout);
+                cm_service->timeout = 0;
+        }
+}
+
+static void
+service_context_install_creation_timeout (CMService *cm_service)
+{
+        service_context_remove_creation_timeout (cm_service);
+
+        cm_service->timeout = g_timeout_add (SERVICE_CREATION_TIMEOUT,
+                                             (GSourceFunc) service_context_create_timeout,
+                                             cm_service);
+}
+
 static void
 service_context_update (CMService *cm_service, CMServiceState new_state)
 {
         if (cm_service->current != new_state) {
                 if (new_state == CM_SERVICE_STATE_ACTIVE) {
-                        if (service_context_create (cm_service) == FALSE)
-                                new_state = CM_SERVICE_STATE_INACTIVE;
-
-                } else if ((new_state == CM_SERVICE_STATE_INACTIVE) &&
-                           (cm_service->context != NULL)) {
+                        service_context_install_creation_timeout (cm_service);
+                } else if (new_state == CM_SERVICE_STATE_INACTIVE) {
+                        service_context_remove_creation_timeout (cm_service);
+                        if (cm_service->context != NULL)
                                 service_context_delete (cm_service);
                 }
 
@@ -247,6 +281,8 @@ cm_service_free (CMService *cm_service)
 
         g_object_unref (cm_service->proxy);
 
+        service_context_remove_creation_timeout (cm_service);
+
         if (cm_service->context != NULL) {
                 g_signal_emit_by_name (cm_service->manager,
                                        "context-unavailable",
-- 
1.9.1

