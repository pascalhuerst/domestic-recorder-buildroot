--- taglib-1.5-orig/taglib/toolkit/tfile.cpp	2009-07-15 14:11:44.000000000 +0200
+++ taglib-1.5/taglib/toolkit/tfile.cpp	2009-07-15 15:43:10.000000000 +0200
@@ -1,6 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2002 - 2008 by Scott Wheeler
-    email                : wheeler@kde.org
+ copyright            : (C) 2002 - 2008 by Scott Wheeler
+ email                : wheeler@kde.org
  ***************************************************************************/
 
 /***************************************************************************
@@ -49,44 +49,167 @@
 # define W_OK 2
 #endif
 
+#include <glib.h>
+
 #define USE_GIO 1
 
 #if USE_GIO
 
 #include <glib.h>
 #include <gio/gio.h>
+#include <tr1/array>
+#include <tr1/memory>
+#include <map>
+#include <list>
 
 namespace FILE_IO
 {
   struct GIOFile
   {
-    GFile *file;
+    enum
+    {
+      CACHE_LINE_SIZE = 1024 * 16
+    };
+
+    struct CacheLine
+    {
+      char buffer[CACHE_LINE_SIZE];
+    };
+
+    typedef std::tr1::shared_ptr<CacheLine> tCacheLinePtr;
+    typedef std::map<int, tCacheLinePtr> tCache;
+    typedef std::list<tCacheLinePtr> tCacheLinePool;
+
+    GIOFile()
+    {
+    }
+
+    ~GIOFile()
+    {
+      tCache::iterator it = cache.begin();
+      for (; it != cache.end(); ++it)
+      {
+        g_static_mutex_lock (&s_pool_cs);
+        s_pool.push_back(it->second);
+	 g_static_mutex_unlock (&s_pool_cs);
+      }
+    }
+
+    int getCacheLinePos(int filePos)
+    {
+      int ret = filePos & ~(CACHE_LINE_SIZE - 1);
+      return ret;
+    }
+
+    void aquire(int where, int len)
+    {
+      int lastSeekedPos = -1;
+
+      while (len > 0)
+      {
+        if (cache.find(where) == cache.end())
+        {
+          if (where != lastSeekedPos)
+          {
+            g_seekable_seek((GSeekable*) stream, where, G_SEEK_SET, NULL, NULL);
+            lastSeekedPos = where;
+          }
+
+          tCacheLinePtr line;
+
+	   g_static_mutex_lock (&s_pool_cs);
+
+          if (s_pool.empty())
+          {
+            line = tCacheLinePtr(new CacheLine);
+          }
+          else
+          {
+            line = s_pool.back();
+            s_pool.pop_back();
+          }
+
+	   g_static_mutex_unlock (&s_pool_cs);
+
+          gsize numBytes = 0;
+          g_input_stream_read_all((GInputStream*) stream, line->buffer, CACHE_LINE_SIZE, &numBytes, NULL, NULL);
+          lastSeekedPos += numBytes;
+
+          cache[where] = line;
+        }
+
+        len -= CACHE_LINE_SIZE;
+        where += CACHE_LINE_SIZE;
+      }
+    }
+
+    int read(int len, char *buf)
+    {
+      int cacheLinePos = getCacheLinePos(seekPos);
+      int overhead = seekPos - cacheLinePos;
+      aquire(cacheLinePos, len + overhead);
+
+      int todo = len;
+
+      while (todo)
+      {
+        int cacheLinePos = getCacheLinePos(seekPos);
+        int overhead = seekPos - cacheLinePos;
+        int forNow = std::min<int>(CACHE_LINE_SIZE - overhead, todo);
+
+        tCacheLinePtr peter = cache.find(cacheLinePos)->second;
+
+        memcpy(buf, &peter->buffer[overhead], forNow);
+        buf += forNow;
+        seekPos += forNow;
+        todo -= forNow;
+      }
+
+      return len;
+    }
+
     GFileInputStream* stream;
+    tCache cache;
+    int length;
+    int seekPos;
+
+    static tCacheLinePool s_pool;
+    static GStaticMutex s_pool_cs;
   };
 
+  GIOFile::tCacheLinePool GIOFile::s_pool;
+  GStaticMutex GIOFile::s_pool_cs = G_STATIC_MUTEX_INIT;
+
   typedef GIOFile tFile;
 
   tFile *open(const char *uri, const char*)
   {
     GIOFile *ret = new GIOFile;
-    ret->file = g_file_new_for_uri(uri);
-    ret->stream = g_file_read(ret->file, NULL, NULL);
+    GFile *file = g_file_new_for_uri(uri);
+    ret->stream = g_file_read(file, NULL, NULL);
+    ret->length = 0;
+    ret->seekPos = 0;
+
+    GFileInfo *inf = g_file_query_info(file, G_FILE_ATTRIBUTE_STANDARD_SIZE, G_FILE_QUERY_INFO_NONE, NULL, NULL);
+    if (inf)
+    {
+      ret->length = g_file_info_get_size(inf);
+      g_object_unref(inf);
+    }
+    g_object_unref(file);
+
     return ret;
   }
 
   void close(tFile *file)
   {
     g_object_unref(file->stream);
-    g_object_unref(file->file);
     delete file;
   }
 
   size_t read(void *ptr, size_t size, size_t count, tFile *file)
   {
-    gsize numBytes = 0;
-    g_input_stream_read_all((GInputStream*)file->stream, ptr, size * count, &numBytes, NULL, NULL);
-    if(numBytes >= 0) return numBytes;
-    return 0;
+    return file->read(size * count, (char*) ptr);
   }
 
   size_t write(const void *, size_t, size_t, tFile *)
@@ -97,23 +212,24 @@
 
   void seek(tFile *file, long int offset, int origin)
   {
-    GSeekType type = G_SEEK_CUR;
-    if(origin == SEEK_SET) type = G_SEEK_SET;
-    else if(origin == SEEK_END) type = G_SEEK_END;
-    g_seekable_seek((GSeekable*)file->stream, offset, type, NULL, NULL);
+
+    if (origin == SEEK_SET)
+      file->seekPos = offset;
+    else if (origin == SEEK_END)
+      file->seekPos = file->length + offset;
+    else if (origin == SEEK_CUR)
+      file->seekPos += offset;
   }
 
   long int tell(tFile *file)
   {
-    long int pos = g_seekable_tell((GSeekable*)(file->stream));
-    if(pos < 0) return pos = 0;
-    return pos;
+    return file->seekPos;
   }
 
   void truncate(tFile *, size_t)
   {
     g_assert(false);
-  }  
+  }
 
   void clearerr(tFile *)
   {
@@ -121,11 +237,7 @@
 
   size_t length(tFile *file)
   {
-    long curpos = tell(file);
-    seek(file, 0, SEEK_END);
-    long endpos = tell(file);
-    seek(file, curpos, SEEK_SET);
-    return endpos;
+    return file->length;
   }
 }
 
@@ -169,7 +281,7 @@
   void truncate(tFile *file, size_t length)
   {
     ftruncate(fileno(file), length);
-  }  
+  }
 
   void clearerr(tFile *file)
   {
@@ -190,7 +302,6 @@
 }
 #endif
 
-
 using namespace TagLib;
 
 #ifdef _WIN32
@@ -201,8 +312,14 @@
 
 struct FileNameHandle : public std::string
 {
-  FileNameHandle(FileName name) : std::string(name) {}
-  operator FileName () const { return c_str(); }
+  FileNameHandle(FileName name) :
+    std::string(name)
+  {
+  }
+  operator FileName() const
+  {
+    return c_str();
+  }
 };
 
 #endif
@@ -223,27 +340,24 @@
 };
 
 File::FilePrivate::FilePrivate(FileName fileName) :
-  file(0),
-  name(fileName),
-  readOnly(true),
-  valid(true),
-  size(0)
+  file(0), name(fileName), readOnly(true), valid(true), size(0)
 {
   // First try with read / write mode, if that fails, fall back to read only.
 
 #ifdef _WIN32
 
-  if(wcslen((const wchar_t *) fileName) > 0) {
+  if(wcslen((const wchar_t *) fileName)> 0)
+  {
 
     file = _wfopen(name, L"rb+");
 
     if(file)
-      readOnly = false;
+    readOnly = false;
     else
-      file = _wfopen(name, L"rb");
+    file = _wfopen(name, L"rb");
 
     if(file)
-      return;
+    return;
 
   }
 
@@ -251,12 +365,12 @@
 
   file = FILE_IO::open(name, "rb+");
 
-  if(file)
+  if (file)
     readOnly = false;
   else
     file = FILE_IO::open(name, "rb");
 
-  if(!file)
+  if (!file)
     debug("Could not open file " + String((const char *) name));
 }
 
@@ -271,7 +385,7 @@
 
 File::~File()
 {
-  if(d->file)
+  if (d->file)
     FILE_IO::close(d->file);
   delete d;
 }
@@ -283,21 +397,21 @@
 
 ByteVector File::readBlock(ulong length)
 {
-  if(!d->file) {
+  if (!d->file)
+  {
     debug("File::readBlock() -- Invalid File");
     return ByteVector::null;
   }
 
-  if(length == 0)
+  if (length == 0)
     return ByteVector::null;
 
-  if(length > FilePrivate::bufferSize &&
-     length > ulong(File::length()))
+  if (length > FilePrivate::bufferSize && length > ulong(File::length()))
   {
     length = File::length();
   }
 
-  ByteVector v(static_cast<uint>(length));
+  ByteVector v(static_cast<uint> (length));
   const int count = FILE_IO::read(v.data(), sizeof(char), length, d->file);
 
   v.resize(count);
@@ -307,10 +421,11 @@
 
 void File::writeBlock(const ByteVector &data)
 {
-  if(!d->file)
+  if (!d->file)
     return;
 
-  if(d->readOnly) {
+  if (d->readOnly)
+  {
     debug("File::writeBlock() -- attempted to write to a file that is not writable");
     return;
   }
@@ -320,8 +435,8 @@
 
 long File::find(const ByteVector &pattern, long fromOffset, const ByteVector &before)
 {
-  if(!d->file || pattern.size() > d->bufferSize)
-      return -1;
+  if (!d->file || pattern.size() > d->bufferSize)
+    return -1;
 
   // The position in the file that the current buffer starts at.
 
@@ -361,21 +476,26 @@
   // then check for "before".  The order is important because it gives priority
   // to "real" matches.
 
-  for(buffer = readBlock(d->bufferSize); buffer.size() > 0; buffer = readBlock(d->bufferSize)) {
+  for (buffer = readBlock(d->bufferSize); buffer.size() > 0; buffer = readBlock(d->bufferSize))
+  {
 
     // (1) previous partial match
 
-    if(previousPartialMatch >= 0 && int(d->bufferSize) > previousPartialMatch) {
+    if (previousPartialMatch >= 0 && int(d->bufferSize) > previousPartialMatch)
+    {
       const int patternOffset = (d->bufferSize - previousPartialMatch);
-      if(buffer.containsAt(pattern, 0, patternOffset)) {
+      if (buffer.containsAt(pattern, 0, patternOffset))
+      {
         seek(originalPosition);
         return bufferOffset - d->bufferSize + previousPartialMatch;
       }
     }
 
-    if(!before.isNull() && beforePreviousPartialMatch >= 0 && int(d->bufferSize) > beforePreviousPartialMatch) {
+    if (!before.isNull() && beforePreviousPartialMatch >= 0 && int(d->bufferSize) > beforePreviousPartialMatch)
+    {
       const int beforeOffset = (d->bufferSize - beforePreviousPartialMatch);
-      if(buffer.containsAt(before, 0, beforeOffset)) {
+      if (buffer.containsAt(before, 0, beforeOffset))
+      {
         seek(originalPosition);
         return -1;
       }
@@ -384,12 +504,14 @@
     // (2) pattern contained in current buffer
 
     long location = buffer.find(pattern);
-    if(location >= 0) {
+    if (location >= 0)
+    {
       seek(originalPosition);
       return bufferOffset + location;
     }
 
-    if(!before.isNull() && buffer.find(before) >= 0) {
+    if (!before.isNull() && buffer.find(before) >= 0)
+    {
       seek(originalPosition);
       return -1;
     }
@@ -398,7 +520,7 @@
 
     previousPartialMatch = buffer.endsWithPartialMatch(pattern);
 
-    if(!before.isNull())
+    if (!before.isNull())
       beforePreviousPartialMatch = buffer.endsWithPartialMatch(before);
 
     bufferOffset += d->bufferSize;
@@ -413,11 +535,10 @@
   return -1;
 }
 
-
 long File::rfind(const ByteVector &pattern, long fromOffset, const ByteVector &before)
 {
-  if(!d->file || pattern.size() > d->bufferSize)
-      return -1;
+  if (!d->file || pattern.size() > d->bufferSize)
+    return -1;
 
   // The position in the file that the current buffer starts at.
 
@@ -427,9 +548,9 @@
   // the end of a buffer.
 
   /*
-  int previousPartialMatch = -1;
-  int beforePreviousPartialMatch = -1;
-  */
+   int previousPartialMatch = -1;
+   int beforePreviousPartialMatch = -1;
+   */
 
   // Save the location of the current read pointer.  We will restore the
   // position using seek() before all returns.
@@ -439,30 +560,35 @@
   // Start the search at the offset.
 
   long bufferOffset;
-  if(fromOffset == 0) {
+  if (fromOffset == 0)
+  {
     seek(-1 * int(d->bufferSize), End);
     bufferOffset = tell();
   }
-  else {
+  else
+  {
     seek(fromOffset + -1 * int(d->bufferSize), Beginning);
     bufferOffset = tell();
   }
 
   // See the notes in find() for an explanation of this algorithm.
 
-  for(buffer = readBlock(d->bufferSize); buffer.size() > 0; buffer = readBlock(d->bufferSize)) {
+  for (buffer = readBlock(d->bufferSize); buffer.size() > 0; buffer = readBlock(d->bufferSize))
+  {
 
     // TODO: (1) previous partial match
 
     // (2) pattern contained in current buffer
 
     long location = buffer.rfind(pattern);
-    if(location >= 0) {
+    if (location >= 0)
+    {
       seek(originalPosition);
       return bufferOffset + location;
     }
 
-    if(!before.isNull() && buffer.find(before) >= 0) {
+    if (!before.isNull() && buffer.find(before) >= 0)
+    {
       seek(originalPosition);
       return -1;
     }
@@ -484,19 +610,21 @@
 
 void File::insert(const ByteVector &data, ulong start, ulong replace)
 {
-  if(!d->file)
+  if (!d->file)
     return;
 
-  if(data.size() == replace) {
+  if (data.size() == replace)
+  {
     seek(start);
     writeBlock(data);
     return;
   }
-  else if(data.size() < replace) {
-      seek(start);
-      writeBlock(data);
-      removeBlock(start + data.size(), replace - data.size());
-      return;
+  else if (data.size() < replace)
+  {
+    seek(start);
+    writeBlock(data);
+    removeBlock(start + data.size(), replace - data.size());
+    return;
   }
 
   // Woohoo!  Faster (about 20%) than id3lib at last.  I had to get hardcore
@@ -511,7 +639,7 @@
 
   ulong bufferLength = bufferSize();
 
-  while(data.size() - replace > bufferLength)
+  while (data.size() - replace > bufferLength)
     bufferLength += bufferSize();
 
   // Set where to start the reading and writing.
@@ -520,7 +648,7 @@
   long writePosition = start;
 
   ByteVector buffer;
-  ByteVector aboutToOverwrite(static_cast<uint>(bufferLength));
+  ByteVector aboutToOverwrite(static_cast<uint> (bufferLength));
 
   // This is basically a special case of the loop below.  Here we're just
   // doing the same steps as below, but since we aren't using the same buffer
@@ -545,7 +673,8 @@
   // Ok, here's the main loop.  We want to loop until the read fails, which
   // means that we hit the end of the file.
 
-  while(!buffer.isEmpty()) {
+  while (!buffer.isEmpty())
+  {
 
     // Seek to the current read position and read the data that we're about
     // to overwrite.  Appropriately increment the readPosition.
@@ -558,7 +687,7 @@
     // Check to see if we just read the last block.  We need to call clear()
     // if we did so that the last write succeeds.
 
-    if(ulong(bytesRead) < bufferLength)
+    if (ulong(bytesRead) < bufferLength)
       clear();
 
     // Seek to the write position and write our buffer.  Increment the
@@ -582,7 +711,7 @@
 
 void File::removeBlock(ulong start, ulong length)
 {
-  if(!d->file)
+  if (!d->file)
     return;
 
   ulong bufferLength = bufferSize();
@@ -590,11 +719,12 @@
   long readPosition = start + length;
   long writePosition = start;
 
-  ByteVector buffer(static_cast<uint>(bufferLength));
+  ByteVector buffer(static_cast<uint> (bufferLength));
 
   ulong bytesRead = 1;
 
-  while(bytesRead != 0) {
+  while (bytesRead != 0)
+  {
     seek(readPosition);
     bytesRead = FILE_IO::read(buffer.data(), sizeof(char), bufferLength, d->file);
     readPosition += bytesRead;
@@ -602,7 +732,7 @@
     // Check to see if we just read the last block.  We need to call clear()
     // if we did so that the last write succeeds.
 
-    if(bytesRead < bufferLength)
+    if (bytesRead < bufferLength)
       clear();
 
     seek(writePosition);
@@ -634,21 +764,23 @@
 
 void File::seek(long offset, Position p)
 {
-  if(!d->file) {
+  if (!d->file)
+  {
     debug("File::seek() -- trying to seek in a file that isn't opened.");
     return;
   }
 
-  switch(p) {
-  case Beginning:
-    FILE_IO::seek(d->file, offset, SEEK_SET);
-    break;
-  case Current:
-    FILE_IO::seek(d->file, offset, SEEK_CUR);
-    break;
-  case End:
-    FILE_IO::seek(d->file, offset, SEEK_END);
-    break;
+  switch (p)
+  {
+    case Beginning:
+      FILE_IO::seek(d->file, offset, SEEK_SET);
+      break;
+    case Current:
+      FILE_IO::seek(d->file, offset, SEEK_CUR);
+      break;
+    case End:
+      FILE_IO::seek(d->file, offset, SEEK_END);
+      break;
   }
 }
 
@@ -666,10 +798,10 @@
 {
   // Do some caching in case we do multiple calls.
 
-  if(d->size > 0)
+  if (d->size > 0)
     return d->size;
 
-  if(!d->file)
+  if (!d->file)
     return 0;
 
   d->size = FILE_IO::length(d->file);
--- taglib-1.5-orig/taglib/mpeg/mpegfile.cpp	2009-07-15 14:11:58.000000000 +0200
+++ taglib-1.5/taglib/mpeg/mpegfile.cpp	2009-07-15 13:37:54.000000000 +0200
@@ -1,6 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2002 - 2008 by Scott Wheeler
-    email                : wheeler@kde.org
+ copyright            : (C) 2002 - 2008 by Scott Wheeler
+ email                : wheeler@kde.org
  ***************************************************************************/
 
 /***************************************************************************
@@ -40,26 +40,20 @@
 
 namespace
 {
-  enum { ID3v2Index = 0, APEIndex = 1, ID3v1Index = 2 };
+  enum
+  {
+    ID3v2Index = 0,
+    APEIndex = 1,
+    ID3v1Index = 2
+  };
 }
 
 class MPEG::File::FilePrivate
 {
 public:
   FilePrivate(ID3v2::FrameFactory *frameFactory = ID3v2::FrameFactory::instance()) :
-    ID3v2FrameFactory(frameFactory),
-    ID3v2Location(-1),
-    ID3v2OriginalSize(0),
-    APELocation(-1),
-    APEFooterLocation(-1),
-    APEOriginalSize(0),
-    ID3v1Location(-1),
-    hasID3v2(false),
-    hasID3v1(false),
-    hasAPE(false),
-    properties(0)
+    ID3v2FrameFactory(frameFactory), ID3v2Location(-1), ID3v2OriginalSize(0), APELocation(-1), APEFooterLocation(-1), APEOriginalSize(0), ID3v1Location(-1), hasID3v2(false), hasID3v1(false), hasAPE(false), properties(0)
   {
-
   }
 
   ~FilePrivate()
@@ -94,22 +88,21 @@
 // public members
 ////////////////////////////////////////////////////////////////////////////////
 
-MPEG::File::File(FileName file, bool readProperties,
-                 Properties::ReadStyle propertiesStyle) : TagLib::File(file)
+MPEG::File::File(FileName file, bool readProperties, Properties::ReadStyle propertiesStyle) :
+  TagLib::File(file)
 {
   d = new FilePrivate;
 
-  if(isOpen())
+  if (isOpen())
     read(readProperties, propertiesStyle);
 }
 
-MPEG::File::File(FileName file, ID3v2::FrameFactory *frameFactory,
-                 bool readProperties, Properties::ReadStyle propertiesStyle) :
+MPEG::File::File(FileName file, ID3v2::FrameFactory *frameFactory, bool readProperties, Properties::ReadStyle propertiesStyle) :
   TagLib::File(file)
 {
   d = new FilePrivate(frameFactory);
 
-  if(isOpen())
+  if (isOpen())
     read(readProperties, propertiesStyle);
 }
 
@@ -140,18 +133,20 @@
 
 bool MPEG::File::save(int tags, bool stripOthers)
 {
-  if(tags == NoTags && stripOthers)
+  if (tags == NoTags && stripOthers)
     return strip(AllTags);
 
-  if(!ID3v2Tag() && !ID3v1Tag() && !APETag()) {
+  if (!ID3v2Tag() && !ID3v1Tag() && !APETag())
+  {
 
-    if((d->hasID3v1 || d->hasID3v2 || d->hasAPE) && stripOthers)
+    if ((d->hasID3v1 || d->hasID3v2 || d->hasAPE) && stripOthers)
       return strip(AllTags);
 
     return true;
   }
 
-  if(readOnly()) {
+  if (readOnly())
+  {
     debug("MPEG::File::save() -- File is read only.");
     return false;
   }
@@ -159,19 +154,21 @@
   // Create the tags if we've been asked to.  Copy the values from the tag that
   // does exist into the new tag.
 
-  if((tags & ID3v2) && ID3v1Tag())
+  if ((tags & ID3v2) && ID3v1Tag())
     Tag::duplicate(ID3v1Tag(), ID3v2Tag(true), false);
 
-  if((tags & ID3v1) && d->tag[ID3v2Index])
+  if ((tags & ID3v1) && d->tag[ID3v2Index])
     Tag::duplicate(ID3v2Tag(), ID3v1Tag(true), false);
 
   bool success = true;
 
-  if(ID3v2 & tags) {
+  if (ID3v2 & tags)
+  {
 
-    if(ID3v2Tag() && !ID3v2Tag()->isEmpty()) {
+    if (ID3v2Tag() && !ID3v2Tag()->isEmpty())
+    {
 
-      if(!d->hasID3v2)
+      if (!d->hasID3v2)
         d->ID3v2Location = 0;
 
       insert(ID3v2Tag()->render(), d->ID3v2Location, d->ID3v2OriginalSize);
@@ -180,60 +177,64 @@
 
       // v1 tag location has changed, update if it exists
 
-      if(ID3v1Tag())
+      if (ID3v1Tag())
         d->ID3v1Location = findID3v1();
 
       // APE tag location has changed, update if it exists
 
-      if(APETag())
-	findAPE();
+      if (APETag())
+        findAPE();
     }
-    else if(stripOthers)
+    else if (stripOthers)
       success = strip(ID3v2, false) && success;
   }
-  else if(d->hasID3v2 && stripOthers)
+  else if (d->hasID3v2 && stripOthers)
     success = strip(ID3v2) && success;
 
-  if(ID3v1 & tags) {
-    if(ID3v1Tag() && !ID3v1Tag()->isEmpty()) {
+  if (ID3v1 & tags)
+  {
+    if (ID3v1Tag() && !ID3v1Tag()->isEmpty())
+    {
       int offset = d->hasID3v1 ? -128 : 0;
       seek(offset, End);
       writeBlock(ID3v1Tag()->render());
       d->hasID3v1 = true;
       d->ID3v1Location = findID3v1();
     }
-    else if(stripOthers)
+    else if (stripOthers)
       success = strip(ID3v1) && success;
   }
-  else if(d->hasID3v1 && stripOthers)
+  else if (d->hasID3v1 && stripOthers)
     success = strip(ID3v1, false) && success;
 
   // Dont save an APE-tag unless one has been created
 
-  if((APE & tags) && APETag()) {
-    if(d->hasAPE)
+  if ((APE & tags) && APETag())
+  {
+    if (d->hasAPE)
       insert(APETag()->render(), d->APELocation, d->APEOriginalSize);
-    else {
-      if(d->hasID3v1) {
+    else
+    {
+      if (d->hasID3v1)
+      {
         insert(APETag()->render(), d->ID3v1Location, 0);
         d->APEOriginalSize = APETag()->footer()->completeTagSize();
         d->hasAPE = true;
         d->APELocation = d->ID3v1Location;
         d->ID3v1Location += d->APEOriginalSize;
       }
-      else {
+      else
+      {
         seek(0, End);
         d->APELocation = tell();
-	d->APEFooterLocation = d->APELocation
-	  + d->tag.access<APE::Tag>(APEIndex, false)->footer()->completeTagSize()
-	  - APE::Footer::size();
+        d->APEFooterLocation = d->APELocation + d->tag.access<APE::Tag> (APEIndex, false)->footer()->completeTagSize() - APE::Footer::size();
         writeBlock(APETag()->render());
         d->APEOriginalSize = APETag()->footer()->completeTagSize();
         d->hasAPE = true;
       }
     }
   }
-  else if(d->hasAPE && stripOthers)
+  else if (d->hasAPE && stripOthers)
     success = strip(APE, false) && success;
 
   return success;
@@ -241,17 +242,17 @@
 
 ID3v2::Tag *MPEG::File::ID3v2Tag(bool create)
 {
-  return d->tag.access<ID3v2::Tag>(ID3v2Index, create);
+  return d->tag.access<ID3v2::Tag> (ID3v2Index, create);
 }
 
 ID3v1::Tag *MPEG::File::ID3v1Tag(bool create)
 {
-  return d->tag.access<ID3v1::Tag>(ID3v1Index, create);
+  return d->tag.access<ID3v1::Tag> (ID3v1Index, create);
 }
 
 APE::Tag *MPEG::File::APETag(bool create)
 {
-  return d->tag.access<APE::Tag>(APEIndex, create);
+  return d->tag.access<APE::Tag> (APEIndex, create);
 }
 
 bool MPEG::File::strip(int tags)
@@ -261,51 +262,56 @@
 
 bool MPEG::File::strip(int tags, bool freeMemory)
 {
-  if(readOnly()) {
+  if (readOnly())
+  {
     debug("MPEG::File::strip() - Cannot strip tags from a read only file.");
     return false;
   }
 
-  if((tags & ID3v2) && d->hasID3v2) {
+  if ((tags & ID3v2) && d->hasID3v2)
+  {
     removeBlock(d->ID3v2Location, d->ID3v2OriginalSize);
     d->ID3v2Location = -1;
     d->ID3v2OriginalSize = 0;
     d->hasID3v2 = false;
 
-    if(freeMemory)
+    if (freeMemory)
       d->tag.set(ID3v2Index, 0);
 
     // v1 tag location has changed, update if it exists
 
-    if(ID3v1Tag())
+    if (ID3v1Tag())
       d->ID3v1Location = findID3v1();
 
     // APE tag location has changed, update if it exists
 
-   if(APETag())
+    if (APETag())
       findAPE();
   }
 
-  if((tags & ID3v1) && d->hasID3v1) {
+  if ((tags & ID3v1) && d->hasID3v1)
+  {
     truncate(d->ID3v1Location);
     d->ID3v1Location = -1;
     d->hasID3v1 = false;
 
-    if(freeMemory)
+    if (freeMemory)
       d->tag.set(ID3v1Index, 0);
   }
 
-  if((tags & APE) && d->hasAPE) {
+  if ((tags & APE) && d->hasAPE)
+  {
     removeBlock(d->APELocation, d->APEOriginalSize);
     d->APELocation = -1;
     d->APEFooterLocation = -1;
     d->hasAPE = false;
-    if(d->hasID3v1) {
-      if(d->ID3v1Location > d->APELocation)
+    if (d->hasID3v1)
+    {
+      if (d->ID3v1Location > d->APELocation)
         d->ID3v1Location -= d->APEOriginalSize;
     }
 
-    if(freeMemory)
+    if (freeMemory)
       d->tag.set(APEIndex, 0);
   }
 
@@ -323,18 +329,20 @@
 
   ByteVector buffer;
 
-  while(true) {
+  while (true)
+  {
     seek(position);
     buffer = readBlock(bufferSize());
 
-    if(buffer.size() <= 0)
+    if (buffer.size() <= 0)
       return -1;
 
-    if(foundLastSyncPattern && secondSynchByte(buffer[0]))
+    if (foundLastSyncPattern && secondSynchByte(buffer[0]))
       return position - 1;
 
-    for(uint i = 0; i < buffer.size() - 1; i++) {
-      if(uchar(buffer[i]) == 0xff && secondSynchByte(buffer[i + 1]))
+    for (uint i = 0; i < buffer.size() - 1; i++)
+    {
+      if (uchar(buffer[i]) == 0xff && secondSynchByte(buffer[i + 1]))
         return position + i;
     }
 
@@ -348,21 +356,23 @@
   bool foundFirstSyncPattern = false;
   ByteVector buffer;
 
-  while (position > 0) {
+  while (position > 0)
+  {
     long size = ulong(position) < bufferSize() ? position : bufferSize();
     position -= size;
 
     seek(position);
     buffer = readBlock(size);
 
-    if(buffer.size() <= 0)
+    if (buffer.size() <= 0)
       break;
 
-    if(foundFirstSyncPattern && uchar(buffer[buffer.size() - 1]) == 0xff)
+    if (foundFirstSyncPattern && uchar(buffer[buffer.size() - 1]) == 0xff)
       return position + buffer.size() - 1;
 
-    for(int i = buffer.size() - 2; i >= 0; i--) {
-      if(uchar(buffer[i]) == 0xff && secondSynchByte(buffer[i + 1]))
+    for (int i = buffer.size() - 2; i >= 0; i--)
+    {
+      if (uchar(buffer[i]) == 0xff && secondSynchByte(buffer[i + 1]))
         return position + i;
     }
 
@@ -375,7 +385,7 @@
 {
   long position = 0;
 
-  if(ID3v2Tag())
+  if (ID3v2Tag())
     position = d->ID3v2Location + ID3v2Tag()->header()->completeTagSize();
 
   return nextFrameOffset(position);
@@ -396,13 +406,13 @@
 
   d->ID3v2Location = findID3v2();
 
-  if(d->ID3v2Location >= 0) {
-
+  if (d->ID3v2Location >= 0)
+  {
     d->tag.set(ID3v2Index, new ID3v2::Tag(this, d->ID3v2Location, d->ID3v2FrameFactory));
 
     d->ID3v2OriginalSize = ID3v2Tag()->header()->completeTagSize();
 
-    if(ID3v2Tag()->header()->tagSize() <= 0)
+    if (ID3v2Tag()->header()->tagSize() <= 0)
       d->tag.set(ID3v2Index, 0);
     else
       d->hasID3v2 = true;
@@ -410,27 +420,33 @@
   else
   {
     // Look for an ID3v1 tag
-    
     d->ID3v1Location = findID3v1();
-    
-    if(d->ID3v1Location >= 0) {
+
+    if (d->ID3v1Location >= 0)
+    {
       d->tag.set(ID3v1Index, new ID3v1::Tag(this, d->ID3v1Location));
       d->hasID3v1 = true;
     }
   }
 
-  // Look for an APE tag
+  // since ape tags implies seeking to the end of the file, we better
+  // only look for ape if no other tag was found so far
 
-  findAPE();
+  d->APELocation = -1;
 
-  if(d->APELocation >= 0) {
+  if(d->ID3v2Location < 0 && d->ID3v1Location < 0)
+  {
+    findAPE();
+  }
 
+  if (d->APELocation >= 0)
+  {
     d->tag.set(APEIndex, new APE::Tag(this, d->APEFooterLocation));
     d->APEOriginalSize = APETag()->footer()->completeTagSize();
     d->hasAPE = true;
   }
 
-  if(readProperties)
+  if (readProperties)
     d->properties = new Properties(this, propertiesStyle);
 
   // Make sure that we have our default tag types available.
@@ -445,7 +461,8 @@
   // of some subtlteies -- specifically the need to look for the bit pattern of
   // an MPEG sync, it has been modified for use here.
 
-  if(isValid() && ID3v2::Header::fileIdentifier().size() <= bufferSize()) {
+  if (isValid() && ID3v2::Header::fileIdentifier().size() <= bufferSize())
+  {
 
     // The position in the file that the current buffer starts at.
 
@@ -479,16 +496,19 @@
     // note this for use in the next itteration, where we will check for the rest
     // of the pattern.
 
-    for(buffer = readBlock(bufferSize()); buffer.size() > 0; buffer = readBlock(bufferSize())) {
+    for (buffer = readBlock(bufferSize()); buffer.size() > 0; buffer = readBlock(bufferSize()))
+    {
 
       // (1) previous partial match
 
-      if(previousPartialSynchMatch && secondSynchByte(buffer[0]))
+      if (previousPartialSynchMatch && secondSynchByte(buffer[0]))
         return -1;
 
-      if(previousPartialMatch >= 0 && int(bufferSize()) > previousPartialMatch) {
+      if (previousPartialMatch >= 0 && int(bufferSize()) > previousPartialMatch)
+      {
         const int patternOffset = (bufferSize() - previousPartialMatch);
-        if(buffer.containsAt(ID3v2::Header::fileIdentifier(), 0, patternOffset)) {
+        if (buffer.containsAt(ID3v2::Header::fileIdentifier(), 0, patternOffset))
+        {
           seek(originalPosition);
           return bufferOffset - bufferSize() + previousPartialMatch;
         }
@@ -497,7 +517,8 @@
       // (2) pattern contained in current buffer
 
       long location = buffer.find(ID3v2::Header::fileIdentifier());
-      if(location >= 0) {
+      if (location >= 0)
+      {
         seek(originalPosition);
         return bufferOffset + location;
       }
@@ -508,17 +529,21 @@
       // (11111111) byte, and we want to check all such instances until we find
       // a full match (11111111 111) or hit the end of the buffer.
 
-      while(firstSynchByte >= 0) {
+      while (firstSynchByte >= 0)
+      {
 
         // if this *is not* at the end of the buffer
 
-        if(firstSynchByte < int(buffer.size()) - 1) {
-          if(secondSynchByte(buffer[firstSynchByte + 1])) {
+        if (firstSynchByte < int(buffer.size()) - 1)
+        {
+          if (secondSynchByte(buffer[firstSynchByte + 1]))
+          {
             // We've found the frame synch pattern.
             seek(originalPosition);
             return -1;
           }
-          else {
+          else
+          {
 
             // We found 11111111 at the end of the current buffer indicating a
             // partial match of the synch pattern.  The find() below should
@@ -552,11 +577,12 @@
 
 long MPEG::File::findID3v1()
 {
-  if(isValid()) {
+  if (isValid())
+  {
     seek(-128, End);
     long p = tell();
 
-    if(readBlock(3) == ID3v1::Tag::fileIdentifier())
+    if (readBlock(3) == ID3v1::Tag::fileIdentifier())
       return p;
   }
   return -1;
@@ -564,17 +590,18 @@
 
 void MPEG::File::findAPE()
 {
-  if(isValid()) {
+  if (isValid())
+  {
     seek(d->hasID3v1 ? -160 : -32, End);
 
     long p = tell();
 
-    if(readBlock(8) == APE::Tag::fileIdentifier()) {
+    if (readBlock(8) == APE::Tag::fileIdentifier())
+    {
       d->APEFooterLocation = p;
       seek(d->APEFooterLocation);
-      APE::Footer footer(readBlock(APE::Footer::size()));
-      d->APELocation = d->APEFooterLocation - footer.completeTagSize()
-	+ APE::Footer::size();
+      APE::Footer footer(readBlock( APE::Footer::size()));
+      d->APELocation = d->APEFooterLocation - footer.completeTagSize() + APE::Footer::size();
       return;
     }
   }
@@ -585,7 +612,7 @@
 
 bool MPEG::File::secondSynchByte(char byte)
 {
-  if(uchar(byte) == 0xff)
+  if (uchar(byte) == 0xff)
     return false;
 
   std::bitset<8> b(byte);
--- taglib-1.5-orig/taglib/mpeg/mpegproperties.cpp	2009-07-15 14:11:58.000000000 +0200
+++ taglib-1.5/taglib/mpeg/mpegproperties.cpp	2009-07-15 13:38:29.000000000 +0200
@@ -1,6 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2002 - 2008 by Scott Wheeler
-    email                : wheeler@kde.org
+ copyright            : (C) 2002 - 2008 by Scott Wheeler
+ email                : wheeler@kde.org
  ***************************************************************************/
 
 /***************************************************************************
@@ -32,23 +32,15 @@
 
 using namespace TagLib;
 
+#define EXCLUDE_VBR 1
+
 class MPEG::Properties::PropertiesPrivate
 {
 public:
   PropertiesPrivate(File *f, ReadStyle s) :
-    file(f),
-    xingHeader(0),
-    style(s),
-    length(0),
-    bitrate(0),
-    sampleRate(0),
-    channels(0),
-    layer(0),
-    version(Header::Version1),
-    channelMode(Header::Stereo),
-    protectionEnabled(false),
-    isCopyrighted(false),
-    isOriginal(false) {}
+    file(f), xingHeader(0), style(s), length(0), bitrate(0), sampleRate(0), channels(0), layer(0), version(Header::Version1), channelMode(Header::Stereo), protectionEnabled(false), isCopyrighted(false), isOriginal(false)
+  {
+  }
 
   ~PropertiesPrivate()
   {
@@ -74,11 +66,12 @@
 // public members
 ////////////////////////////////////////////////////////////////////////////////
 
-MPEG::Properties::Properties(File *file, ReadStyle style) : AudioProperties(style)
+MPEG::Properties::Properties(File *file, ReadStyle style) :
+  AudioProperties(style)
 {
   d = new PropertiesPrivate(file, style);
 
-  if(file && file->isOpen())
+  if (file && file->isOpen())
     read();
 }
 
@@ -148,10 +141,12 @@
 
 void MPEG::Properties::read()
 {
+
   long first = d->file->firstFrameOffset();
   long last = d->file->lastFrameOffset();
 
-  if(first < 0) {
+  if (first < 0)
+  {
     debug("MPEG::Properties::read() -- Could not find a valid first MPEG frame in the stream.");
     return;
   }
@@ -161,10 +156,12 @@
   d->file->seek(first);
   Header firstHeader(d->file->readBlock(4));
 
-  if(!firstHeader.isValid()) {
+  if (!firstHeader.isValid())
+  {
     last = d->file->lastFrameOffset();
 
-    if(last < 0) {
+    if (last < 0)
+    {
       debug("MPEG::Properties::read() -- Could not find a valid last MPEG frame in the stream.");
       return;
     }
@@ -172,57 +169,57 @@
     d->file->seek(last);
     Header lastHeader(d->file->readBlock(4));
 
-    if(!lastHeader.isValid()) {
-      
+    if (!lastHeader.isValid())
+    {
       long pos = last;
-      
-      while(pos > first) {
-	
-	pos = d->file->previousFrameOffset(pos);
-	
-	if(pos < 0)
-	  break;
-
-	d->file->seek(pos);
-	Header header(d->file->readBlock(4));
-	
-	if(header.isValid()) {
-	  lastHeader = header;
-	  last = pos;
-	  break;
-	}
+
+      while (pos > first)
+      {
+
+        pos = d->file->previousFrameOffset(pos);
+
+        if (pos < 0)
+          break;
+
+        d->file->seek(pos);
+        Header header(d->file->readBlock(4));
+
+        if (header.isValid())
+        {
+          lastHeader = header;
+          last = pos;
+          break;
+        }
       }
     }
 
-    if(!lastHeader.isValid())
+    if (!lastHeader.isValid())
     {
       debug("MPEG::Properties::read() -- Page headers were invalid.");
       return;
     }
   }
 
+#if !EXCLUDE_VBR
   // Check for a Xing header that will help us in gathering information about a
   // VBR stream.
 
-  int xingHeaderOffset = MPEG::XingHeader::xingHeaderOffset(firstHeader.version(),
-                                                            firstHeader.channelMode());
+  int xingHeaderOffset = MPEG::XingHeader::xingHeaderOffset(firstHeader.version(), firstHeader.channelMode());
 
   d->file->seek(first + xingHeaderOffset);
   d->xingHeader = new XingHeader(d->file->readBlock(16));
 
   // Read the length and the bitrate from the Xing header.
 
-  if(d->xingHeader->isValid() &&
-     firstHeader.sampleRate() > 0 &&
-     d->xingHeader->totalFrames() > 0)
+  if (d->xingHeader->isValid() && firstHeader.sampleRate() > 0 && d->xingHeader->totalFrames() > 0)
   {
-      double timePerFrame =
-        double(firstHeader.samplesPerFrame()) / firstHeader.sampleRate();
+    double timePerFrame = double(firstHeader.samplesPerFrame()) / firstHeader.sampleRate();
 
-      d->length = int(timePerFrame * d->xingHeader->totalFrames());
-      d->bitrate = d->length > 0 ? d->xingHeader->totalSize() * 8 / d->length / 1000 : 0;
+    d->length = int(timePerFrame * d->xingHeader->totalFrames());
+    d->bitrate = d->length > 0 ? d->xingHeader->totalSize() * 8 / d->length / 1000 : 0;
   }
-  else {
+  else
+  {
     // Since there was no valid Xing header found, we hope that we're in a constant
     // bitrate file.
 
@@ -231,16 +228,21 @@
 
     // TODO: Make this more robust with audio property detection for VBR without a
     // Xing header.
+#else
+  {
+#endif
+
 
-    if(firstHeader.frameLength() > 0 && firstHeader.bitrate() > 0) {
+    if (firstHeader.frameLength() > 0 && firstHeader.bitrate() > 0)
+    {
       int frames = (last - first) / firstHeader.frameLength() + 1;
 
-      d->length = int(float(firstHeader.frameLength() * frames) /
-                      float(firstHeader.bitrate() * 125) + 0.5);
+      d->length = int(float(firstHeader.frameLength() * frames) / float(firstHeader.bitrate() * 125) + 0.5);
       d->bitrate = firstHeader.bitrate();
     }
   }
 
+
   d->sampleRate = firstHeader.sampleRate();
   d->channels = firstHeader.channelMode() == Header::SingleChannel ? 1 : 2;
   d->version = firstHeader.version();
